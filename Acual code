import random


#colors
colors = ("\x1b[30m","\x1b[31m","\x1b[32m","\x1b[33m","\x1b[34m","\x1b[35m","\x1b[36m","\x1b[37m","\x1b[38m","\x1b[39m")
#black, red, green, yellow, blue, megenta, cyan, white, default


print("")
print("Welcome to Otocat714's Crappy adventure game that will be the opposite of a corn maze")
print(colors[2]+"Please imput your name, social security number, or mental state\n"+colors[9])
idiotloop = 1
while idiotloop == 1:
    a = input()
    if a != "":
        idiotloop = 0
    else:
        print(colors[2]+"Please imput your name, social security number, or mental state\n"+colors[9])
name = colors[4]+a+colors[9]

print("Hello, ",name)
print("Because im lazy and don't want to think of proper game design right now, the gameplay will be as follows")
print("You are going to be playing a equivilent of offbrand pokemon but you don't have any pokemon")
print("what I just said is totaly wrong and this is accualy a deck building game")




indecisiveloop = 1
valid = ["1","2","3"]
if name == "\x1b[34mbug\x1b[39m":
    valid.append("0")
while indecisiveloop == 1:
    input(colors[2]+"Press enter to continue"+colors[9])
    print("---------------------------")
    if name == "\x1b[34mbug\x1b[39m":
        print(colors[1]+"0 Bugtester"+colors[9])
    print("1 Rouge")
    print("2 Warrior (WIP)")
    print("3 Mage (WIP)")
    print("4 Priest (N/A)")
    print("---------------------------")
    a = input(colors[2]+"Pick your class"+colors[9])
    if a in valid:
        if a == "0":
            print("---------------------------")
            print(colors[1]+"for bugtesting, invalidates speedruns if that ever becomes a thing")
            print("Cards: ATK 1,ATK 2,HEAL 1,HEAL 2")
            print("Stats: HP:100,ATK:1,MATK:1,DF:1,AP:100,MP:100,$:1000,Hand:2"+colors[9])
            print("---------------------------")
            a = input(colors[2]+"Confirm? (type in yes)"+colors[9]).strip()
            if a == "Yes" or a == "yes" or a == "y" or a == "Confirm" or a == "confirm":
                indecisiveloop = 0
                MaxHP = 100
                HP = 100
                ATK = 1
                MATK = 1
                DF = 1
                AP = 0
                MAP = 100
                MP = 0
                MMP = 100
                currency = 1000
                Deck = [0,0,1,1,2,2,3,3]
                Hand_limit = 8
        elif a == "1":
            print("---------------------------")
            print("Classic rouge")
            print("Cards: Stab(4),Backstab(2),Conceal,Dark Bolt")
            print("Stats: HP:7,ATK:1.3,MATK:1,DF:1,AP:10,MP:7,$:10,Hand:3")
            print("---------------------------")
            a = input(colors[2]+"Confirm? (type in yes)"+colors[9]).strip()
            if a == "Yes" or a == "yes" or a == "y" or a == "Confirm" or a == "confirm":
                indecisiveloop = 0
                MaxHP = 7
                HP = 7
                ATK = 1.3
                MATK = 1
                DF = 1
                AP = 0
                MAP = 10
                MP = 0
                MMP = 7
                currency = 10
                Deck = [4,4,4,4,5,5,6,7]
                Hand_limit = 3
        elif a == "2":
            print("---------------------------")
            print("Just a traveling swordsmen")
            print("Cards: Strike(2), Harden, Mend")
            print("Stats: HP:12,ATK:1.1,MATK:1.1,DF:1,AP:15,MP:10,$:5,Hand:2")
            print("---------------------------")
            a = input(colors[2]+"Confirm? (type in yes)"+colors[9]).strip()
            if a == "Yes" or a == "yes" or a == "y" or a == "Confirm" or a == "confirm":
                indecisiveloop = 0
                MaxHP = 12
                HP = 12
                ATK = 1.1
                MATK = 1.1
                DF = 1.1
                AP = 0
                MAP = 15
                MP = 0
                MMP = 10
                currency = 5
                Deck = [8,8,9,13]
                Hand_limit = 2
        elif a == "3":
            print("---------------------------")
            print("Just cast fireball!")
            print("Cards: firebolt(4) ,Firewall(2)")
            print("Stats: HP:7,ATK:0.5,MATK:1.5,DF:1,AP:5,MP:12,$:10,Hand:2")
            print("---------------------------")
            a = input(colors[2]+"Confirm? (type in yes)"+colors[9]).strip()
            if a == "Yes" or a == "yes" or a == "y" or a == "Confirm" or a == "confirm":
                indecisiveloop = 0
                MaxHP = 7
                HP = 7
                ATK = 0.5
                MATK = 1.5
                DF = 1
                AP = 0
                MAP = 5
                MP = 12
                MMP = 20
                currency = 10
                Deck = [10,10,10,10,11,11]
                Hand_limit = 2

#Base Player setup
shield = 0
Discard = []
Effects = []
Effectsstack = []
Effectslv = []


#Data

#statuses
status_description = {"Conceal": "(Conceal: When you play a pysical attack card, you deal 1.5x, and it removes a stack. When you end your turn, take no damage and remove a stack)","Burn":"durring the next turn, the effected takes [burn level], and removes one stack"}
#moves data
cards_atk = (1,2,-1,-2,2,4,0,4,2,0,3,0,6,-2)
cards_def = (0,0,0,0,0,0,0,0,0,2,0,2,0,0)
cards_type = (0,0,"1_2","1_2",0,0,"0_1_3","1_3",0,0,"1_4","1_4","0_1_4","1_2")
cards_ap_cost = (0,0,0,0,0,2,5,0,0,2,0,0,4,0)
cards_mp_cost = (0,0,0,0,0,0,5,4,0,0,4,6,2,5)
cards_names = ("ATK 1","ATK 2","HEAL 1","HEAL 2","Stab","Backstab","Conceal","Dark Bolt","Strike","Harden","Firebolt","Firewall","Flaming Blade","Mend")
cards_description = ("Deals 1 damage","deals 2 damage","deals -1 damage","deals -2 damage","Basic atack\nDamage:2\n[Pysical]","How creative\nAP:2\nDamage:4\n[Pysical]","Grants one stack of conceal. Allways targets self\nAP:5\nMP:5\n[Pysical][Magical][Dark]\n\n"+status_description["Conceal"],"Magic bolt of darkness\nMP:4\nDamage:4\n[Magical][Dark]","Basic attack\nDamage:2\[Pysical]","Basic defense. Only targets allys\nAP:2\nShield:2\n[Pysical]","Lauch a high speed fire pellet. Inflicts 3 stacks of Lv1 burn\nMP:4\nDamage:3\n[Magical][Fire]\n\n"+status_description["Burn"],"Inflicts burn on any attackers\nMP:6\nDF:2\n[Magical][Fire]","Imbue your weapon with fire before striking\nAP:4\nMP:2\nDamage:6\n[Pysical][Magical][Fire]","Basic Healing\nMP:5\nHeal:2\n[Magical][Holy]")
cards_def_price = (10,10,10,10,2,5,10,5,2,5,3,4,5,2)
#typings
#0 pysical
#1 Magic
#2 Holy
#3 Dark
#4 Fire
#5 Water
#enemies data
enemy = []
enemydesplayname = []
enemyMaxHP = []
enemyHP = []
enemyHPBar = []
enemyHPBardesplay = []
asdf1 = []
asdf2 = []
asdf3 = []
asdf4 = []
asdf5 = []
asdf6 = []
asdf7 = []
asdf8 = []
asdf9 = []
asdf10 = []
asdf11 = []
asdf12 = []
asdf13 = []
asdf14 = []
asdf15 = []
asdf16 = []
asdf17 = []
asdf18 = []
asdf19 = []
asdf20 = []
enemyeffects = [asdf1,asdf2,asdf3,asdf4,asdf5,asdf6,asdf7,asdf8,asdf9,asdf10,asdf11,asdf12,asdf13,asdf14,asdf15,asdf16,asdf17,asdf18,asdf19,asdf20]
sasdf1 = []
sasdf2 = []
sasdf3 = []
sasdf4 = []
sasdf5 = []
sasdf6 = []
sasdf7 = []
sasdf8 = []
sasdf9 = []
sasdf10 = []
sasdf11 = []
sasdf12 = []
sasdf13 = []
sasdf14 = []
sasdf15 = []
sasdf16 = []
sasdf17 = []
sasdf18 = []
sasdf19 = []
sasdf20 = []
enemyeffectsstack = [sasdf1,sasdf2,sasdf3,sasdf4,sasdf5,sasdf6,sasdf7,sasdf8,sasdf9,sasdf10,sasdf11,sasdf12,sasdf13,sasdf14,sasdf15,sasdf16,sasdf17,sasdf18,sasdf19,sasdf20]
aasdf1 = []
aasdf2 = []
aasdf3 = []
aasdf4 = []
aasdf5 = []
aasdf6 = []
aasdf7 = []
aasdf8 = []
aasdf9 = []
aasdf10 = []
aasdf11 = []
aasdf12 = []
aasdf13 = []
aasdf14 = []
aasdf15 = []
aasdf16 = []
aasdf17 = []
aasdf18 = []
aasdf19 = []
aasdf20 = []
enemyeffectslv = [aasdf1,aasdf2,aasdf3,aasdf4,aasdf5,aasdf6,aasdf7,aasdf8,aasdf9,aasdf10,aasdf11,aasdf12,aasdf13,aasdf14,aasdf15,aasdf16,aasdf17,aasdf18,aasdf19,aasdf20]




allenemies_MaxHP = (5,10)
allenemies_desplayname = ("sans","zombie")
allenemies_atk = (4,2)
allenemies_week = ("1","1_2")
allenemies_monney = (20,10)
#map saves
map_saves = []
map_saves_location = []
biome_list = (0,1,2,3)
biome_mob_chance=(10,10,10,10,1,1,1,1,1,1,1)
biome_desplay=(colors[4]+"\u26C6"+colors[9],colors[2]+"\u2667"+colors[9],colors[3]+"\u2637"+colors[9],"\u26F0","\u2610","\u26CB","\u26EA","\u26EB",colors[3]+"\u2630"+colors[9],colors[2]+"\u26EC"+colors[9],"\u26C0")
biome_mobs=("","0,1","0,1","0,1","","","","","","","")
valid_stuff = ("","0","0","1","","","","","","")
locations = ["Player"]
locations_location = ["0,0"]
locations_map_location = ["14,14"]
locations_submaps = ["N/A"]
locations_submaps_spawn = ["N/A"]
gamestate = 0





#temp, sets the current turn to player
turn = 1



def debug(msg):
    if name == "\x1b[34mbug\x1b[39m":
        print("DEBUG-0")
        print(msg)
        print("DEBUG-1")
def Encoutner_setup():
    global enemyHPBar
    global enemyMaxHP
    global enemyHP
    global enemydesplayname
    global HPBar
    global HPBardesplay
    global MaxHP
    global Hand
    global Discard
    global HP
    global Handdelt
    global enemy
    global AP
    global MAP
    global MP
    global MMP
    global APBar
    global MPBar
    global shield
    Handdelt = 0
    MP = MMP
    AP = MAP
    shield = 0



    for i in range(0,len(enemy)):
        enemydesplayname.append(allenemies_desplayname[enemy[i]])
        enemyMaxHP.append(allenemies_MaxHP[enemy[i]])
        enemyHP.append(enemyMaxHP[i])
        
        
        
        
        #setting the lengths of the HP bars
        if enemyMaxHP[i] <= 10:
            enemyHPBar.append(10)
        else:
            enemyHPBar[i] = 10
            while enemyHPBar[i] <= ((enemyMaxHP[i]-10)/(enemyHPBar[i]*0.1)):
                enemyHPBar[i] += 1
            enemyHPBar[i] -= 1
    
    
    if MaxHP <= 10:
        HPBar = 10
    else:
        HPBar = 10
        while HPBar <= ((MaxHP-10)/(HPBar*0.1)):
            HPBar += 1
        HPBar -= 1
    if MAP <= 10:
        APBar = 10
    else:
        APBar = 10
        while APBar <= ((MAP-10)/(APBar*0.1)):
            APBar += 1
        APBar -= 1
    if MMP <= 10:
        MPBar = 10
    else:
        MPBar = 10
        while MPBar <= ((MMP-10)/(MPBar*0.1)):
            MPBar += 1
        MPBar -= 1
def Refresh_hud():
    #start of enemy HP bar refresh
    global enemyHPBar
    global enemyMaxHP
    global enemyHP
    global enemydesplayname
    global HPBar
    global HPBardesplay
    global MaxHP
    global Hand
    global Discard
    global HP
    global turn
    global Deck
    global Handdelt
    global name
    global DF
    global AP
    global MAP
    global MP
    global MMP
    global MPBar
    global APBar
    global DF
    global shield
    global asdf1,asdf2,asdf3,asdf4,asdf5,asdf6,asdf7,asdf8,asdf9,asdf10,asdf11,asdf12,asdf13,asdf14,asdf15,asdf16,asdf17,asdf18,asdf19,asdf20,aasdf1,aasdf2,aasdf3,aasdf4,aasdf5,aasdf6,aasdf7,aasdf8,aasdf9,aasdf10,aasdf11,aasdf12,aasdf13,aasdf14,aasdf15,aasdf16,aasdf17,aasdf18,aasdf19,aasdf20,sasdf1,sasdf2,sasdf3,sasdf4,sasdf5,sasdf6,sasdf7,sasdf8,sasdf9,sasdf10,sasdf11,sasdf12,sasdf13,sasdf14,sasdf15,sasdf16,sasdf17,sasdf18,sasdf19,sasdf20
    global currency
    if len(enemy) > 20:
        print("go add more variables so effects support more then 20")
        OSError.exit()
    if enemy == "":
        pass
    else:
        for i in range(0,len(enemy)):
            if len(enemyHPBardesplay) < len(enemy): 
                enemyHPBardesplay.append("")
            enemyHPBardesplay[i] = ""
            enemyHPBardesplaycounter = 0
            enemyHPBarrefresh = enemyHPBar[i]
            enemyHPBarrefresh *= enemyHP[i]/enemyMaxHP[i]
            while enemyHPBardesplaycounter < enemyHPBarrefresh:
                enemyHPBardesplay[i] += colors[2]+"X"+colors[9]
                enemyHPBardesplaycounter += 1
            while enemyHPBardesplaycounter < enemyHPBar[i]:
                enemyHPBardesplay[i] += colors[1]+"O"+colors[9]
                enemyHPBardesplaycounter += 1
        
        HPBardesplay = ""
        HPBardesplaycounter = 0
        HPBarrefresh = HPBar
        HPBarrefresh *= HP/MaxHP
        while HPBardesplaycounter < HPBarrefresh:
            HPBardesplay += colors[2]+"X"+colors[9]
            HPBardesplaycounter += 1
        while HPBardesplaycounter < HPBar:
            HPBardesplay += colors[1]+"O"+colors[9]
            HPBardesplaycounter += 1


        APBardesplay = ""
        APBardesplaycounter = 0
        APBarrefresh = APBar
        APBarrefresh *= AP/MAP
        while APBardesplaycounter < APBarrefresh:
            APBardesplay += colors[3]+"X"+colors[9]
            APBardesplaycounter += 1
        while APBardesplaycounter < APBar:
            APBardesplay += colors[1]+"O"+colors[9]
            APBardesplaycounter += 1
        
        
        MPBardesplay = ""
        MPBardesplaycounter = 0
        MPBarrefresh = MPBar
        MPBarrefresh *= MP/MMP
        while MPBardesplaycounter < MPBarrefresh:
            MPBardesplay += colors[6]+"X"+colors[9]
            MPBardesplaycounter += 1
        while MPBardesplaycounter < MPBar:
            MPBardesplay += colors[1]+"O"+colors[9]
            MPBardesplaycounter += 1



        #Hand dealing
        if Handdelt == 0:
            Hand = []
            temp3 = 0
            while len(Hand) < Hand_limit and temp3 == 0:
                if len(Deck) == 0:
                    if Discard == 0:
                        temp3 = 1
                    else:    
                        Deck = Discard
                        Discard = []
                else:
                    temp = random.randint(0,len(Deck)-1)
                    temp2 = Deck[temp]
                    Deck.pop(temp)
                    Hand.append(temp2)
            Handdelt = 1
        debug(Deck) 
        debug(Hand)

        count = 0
        
        #end of HP bar refresh
        #desplay
        if name == "\x1b[34mbug\x1b[39m":
            print(enemy,"enemy")
            print(enemydesplayname,"enemydesplayname")
            print(enemyHP,"enemyHP")
            print(enemyHPBar,"enemyHPBar")
            print(enemyHPBardesplay,"enemyHPBardesplay")
            print(enemyHPBarrefresh,"enemyHPBarrefresh")
            print(enemyMaxHP,"enemyMaxHP")
            print("1>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            for i in range(0,len(enemy)):
                print("2",enemydesplayname[i],"<",enemyHPBardesplay[i],">",enemyHP[i],enemyMaxHP[i])
            print("3")
            print("4")
            print("5")
            print("6")
            print("7")
            print("8")
            print("9>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            print('10 "'+name+'" <',HPBardesplay,">","[",APBardesplay,"]","{",MPBardesplay,"}","\u26C9:",shield)
        else:
            print("1>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            for i in range(0,len(enemy)):
                print("2",enemydesplayname[i],"<",enemyHPBardesplay[i],">")
            print("3")
            print("4")
            print("5")
            print("6")
            print("7")
            print("8")
            print("9>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
            print('10 "'+name+'" <',HPBardesplay,">","[",APBardesplay,"]","{",MPBardesplay,"}","\u26C9:",shield)
        #11- (Hand)
        while count < len(Hand):
            print(count+11,cards_names[Hand[count]])
            count += 1
        print(len(Hand)+11,"Pass")
        #spacer
        print()
        
        if turn == 1:
            AP += MAP/10
            MP += MAP/10
            if AP > MAP:
                AP = MAP
            if MP > MMP:
                MP = MMP
            valid_awnsers = [2,3,4,5,6,7,8,10,len(Hand)+11]

            count = 11
            while len(valid_awnsers) - 9 < len(Hand):
                valid_awnsers.append(count)
                count += 1
        
            idiotloop = 0
            while idiotloop == 0:
                try:
                    examine = int(input(colors[2]+"Insert # to examine\n"+colors[9]))
                    idiotloop = 1
                except:
                    print(colors[1]+"Invalid input, valid inputs include",str(valid_awnsers)+colors[9])




        
            idiotloop = 0
            while idiotloop == 0:
                count = valid_awnsers.count(examine)
                if examine in valid_awnsers:
                    idiotloop = 1
                else:
                    print(colors[1]+"Invalid input, valid inputs include",str(valid_awnsers)+colors[9])
                    try:
                        examine = int(input())
                    except:
                        pass
            print("---------------------------------------------")
            if examine == 2:
                print("Your opponent")
                #might later add stuff here for closer examination if they have a certain item
            if examine > 2 and examine < 9:
                print("currently empty space, I might add ACCSI art here later")
                print("probobly not though that would be a pain in the butt")
            if examine == 10:
                print("Its you!")
                print("HP:",HP)
                print("Max HP:",MaxHP)
                print("Effects:",Effects, Effectsstack)
                if HP/MaxHP < 0.1:
                    print("might not be soon though")
            if examine > 10 and examine < len(Hand)+11:
                print("Action : "+cards_names[Hand[examine-11]])
                print("Description : "+cards_description[Hand[examine-11]])
                temp = input(colors[2]+"Press enter to go back, input positive # to target opponents, negitave # to target allies\nex. (1 to target first opponent, -1 to target first ally)"+colors[9])
                try:
                    int(temp)
                    if int(temp) > len(enemy) or int(temp) == 0:
                        print(colors[1]+"Invalid target"+colors[9])
                        raise Exception()
                    if cards_ap_cost[Hand[examine-11]] > AP or cards_mp_cost[Hand[examine-11]] > MP:
                        print("Not enough Energy/Mana")
                        raise Exception()
                except:
                    pass
                else:
                    Play_card(Hand[examine-11],int(temp))
            elif examine == len(Hand)+11:
                print("End turn")
                temp = input(colors[2]+"Press enter to go back, input 1 to continue\n"+colors[9])
                if temp == "1":
                    turn = 0
                    while len(Hand) > 0:
                        Discard.append(Hand[0])
                        Hand.pop(0)
        else:
            kills = 0
            for i in range(0,len(enemy)):
                
               
                
                damagey = allenemies_atk[enemy[i-kills]]/DF
                damagey -= shield
                if damagey <0:
                    shield = damagey *-1
                    damagey = 0


                if "Conceal" in Effects and damagey != 0:
                    if Effectsstack[Effects.index("Conceal")] >0:
                        damagey = 0
                
                

                HP -= damagey
                print("You took",damagey,"damage")
                

                if "Burn" in Effects:
                    HP -= Effectslv[Effects.index("Burn")]
                    Effectsstack[Effects.index("Burn")] -= 1
                    print("You also took",Effectslv[Effects.index("Burn")],"burn damage")
                if "Burn" in enemyeffects[i-kills]:
                    enemyHP[i-kills] -= enemyeffectslv[i-kills][enemyeffects[i-kills].index("Burn")]
                    enemyeffectsstack[i-kills][enemyeffects[i-kills].index("Burn")] -= 1
                    print(enemydesplayname[i-kills],"took",enemyeffectslv[i-kills][enemyeffects[i-kills].index("Burn")],"burn damage")
                
                
                
                if enemyHP[i-kills] <= 0:
                    currency += allenemies_monney[enemy[i-kills]]
                    enemy.pop(i-kills)
                    enemydesplayname.pop(i-kills)
                    enemyHP.pop(i-kills)
                    enemyHPBar.pop(i-kills)
                    enemyHPBardesplay.pop(i-kills)
                    enemyeffectslv.pop(i-kills)
                    enemyeffectsstack.pop(i-kills)
                    enemyeffects.pop(i-kills)
                    kills += 1
            #removes effects
            effectsremove = []
            for i in range(0,len(Effects)):
                if Effectsstack[i] >= 0:
                    effectsremove.append(i)
            effectsremove.reverse()
            for i in range(0,len(effectsremove)):
                Effects.pop(effectsremove[i])
                Effectsstack.pop(effectsremove[i])
            
            
            turn = 1
            Handdelt = 0
            
                    

            
        
        print()
        print("--------------------------------------------")
        input(colors[2]+"press enter to continue\n"+colors[9])
def Play_card(card,target):
    global enemy, enemydesplayname, enemyHPBar, enemyHPBardesplaycounter, enemyHPBardesplay, enemyHPBarrefresh
    global enemyHP
    global enemyMaxHP
    global HP
    global MaxHP
    global DF
    global ATK
    global MATK
    global cards_type
    global cards_atk
    global cards_def
    global Effects
    global Effectsstack
    global Effectslv
    global enemyeffects
    global enemyeffectsstack
    global enemyeffectslv
    global AP
    global MP
    global cards_mp_cost
    global cards_ap_cost
    global shield
    global asdf1,asdf2,asdf3,asdf4,asdf5,asdf6,asdf7,asdf8,asdf9,asdf10,asdf11,asdf12,asdf13,asdf14,asdf15,asdf16,asdf17,asdf18,asdf19,asdf20,aasdf1,aasdf2,aasdf3,aasdf4,aasdf5,aasdf6,aasdf7,aasdf8,aasdf9,aasdf10,aasdf11,aasdf12,aasdf13,aasdf14,aasdf15,aasdf16,aasdf17,aasdf18,aasdf19,aasdf20,sasdf1,sasdf2,sasdf3,sasdf4,sasdf5,sasdf6,sasdf7,sasdf8,sasdf9,sasdf10,sasdf11,sasdf12,sasdf13,sasdf14,sasdf15,sasdf16,sasdf17,sasdf18,sasdf19,sasdf20
    global currency
    #special card effects
    if card == 6:
        if "Conceal" in Effects:
            Effectsstack[Effects.index("Conceal")] += 1
        else:
            Effects.append("Conceal")
            Effectsstack.append(1)
            Effectslv.append(1)
    if card == 10:
        if target > 0:
            if "Burn" in enemyeffects[target-1]:
                if enemyeffectslv[target-1][enemyeffects[target-1].index("Burn")] > 1:
                    pass
                else:
                    enemyeffectsstack[target-1][enemyeffects[target-1].index("Burn")] += 3
                    if enemyeffectslv[target-1][enemyeffects[target-1].index("Burn")] < 1:
                        enemyeffectslv[target-1][enemyeffects[target-1].index("Burn")] = 1
            else:
                enemyeffects[target-1].append("Burn")
                enemyeffectsstack[target-1].append(3)
                enemyeffectslv[target-1].append(1)
        else:
            if "Burn" in Effects:
                if Effectslv[Effects.index("Burn")] > 1:
                    pass
                else:
                    Effectsstack[Effects.index("Burn")] += 3
                    if Effectslv[Effects.index("Burn")] < 1:
                        Effectslv[Effects.index("Burn")] = 1
            else:
                Effects.append("Burn")
                Effectsstack.append(3)
                Effectslv.append(1)
    debug("card:"+str(card))
    debug(Effects)
    debug(Effectsstack)
    
    
    #ap/mp cost
    debug("ap/mp cost")
    AP -= cards_ap_cost[card]
    MP -= cards_mp_cost[card]
    
    
    
    #base dam
    damagey = cards_atk[card]
    debug("q")
    
    #additional stat dam
    if type(cards_type[card]) == int:
        card_type = []
        card_type.append(cards_type[card])
    else:
        card_type = cards_type[card].split("_")
        for i in range(0,len(card_type)):
            card_type[i] = int(card_type[i])
    debug(card_type)

    if 0 in card_type:
        damagey *= ATK
    if 1 in card_type:
        damagey *= MATK
    debug("w")
    

    #shield
    shield += cards_def[card]
    
    
    if target > 0:
        
        
        #weeknesses
        weeknesses = allenemies_week[allenemies_desplayname.index(enemydesplayname[target-1])].split("_")
        for i in range(0,len(weeknesses)):
            weeknesses[i] = int(weeknesses[i])
        for i in range(0,len(card_type)):
            if card_type[i] in weeknesses:
                damagey *=2
        
        
        #holy heal damage
        if damagey < 0 and 2 in weeknesses:
            damagey *=-1
        
        #conceal
        debug(Effects)
        if "Conceal" in Effects:
            if damagey > 0 and 0 in card_type:
                damagey *= 1.5
                Effectsstack[Effects.index("Conceal")] -= 1
        debug(Effectsstack)
        #impact damage
        enemyHP[target-1] -= damagey
    else:
        weeknesses = "N/A"
        debug("436")
        HP -= damagey
        debug("438")
        print(weeknesses)
    print("you did ",damagey, "damage")




    #prevent overheal
    debug("prevent overheal")
    if target > 0:
        if enemyHP[target-1] > enemyMaxHP[target-1]:
            enemyHP[target-1] = enemyMaxHP[target-1]
    if HP > MaxHP:
        HP = MaxHP
    #check to see if the guy is dead
    debug("check to see if the guy is dead")
    if target > 0:
        if enemyHP[target-1] <= 0:
            currency += allenemies_monney[enemy[target-1]]
            enemy.pop(target-1)
            enemydesplayname.pop(target-1)
            enemyHP.pop(target-1)
            enemyHPBar.pop(target-1)
            enemyHPBardesplay.pop(target-1)
            enemyeffectslv.pop(target-1)
            enemyeffectsstack.pop(target-1)
            enemyeffects.pop(target-1)

    #remove effects
    effectsremove = []
    for i in range(0,len(Effects)):
        if Effectsstack[i] <= 0:
            effectsremove.append(i)
    effectsremove.reverse()
    for i in range(0,len(effectsremove)):
        Effects.pop(effectsremove[i])
        Effectsstack.pop(effectsremove[i])
        Effectslv.pop(effectsremove[i])

    
    
    debug("discard")
    #put card in discard
    Discard.append(card)
    Hand.remove(card)
def Refresh_Map(map):
    global enemy
    global map_saves
    global map_saves_location
    global locations_submaps
    global locations
    global locations_location
    global locations_map_location
    global biome_mob_chance
    global gamestate
    global biome_desplay

    map1  = []
    map2  = []
    map3  = []
    map4  = []
    map5  = []
    map6  = []
    map7  = []
    map8  = []
    map9  = []
    map10 = []
    map11 = []
    map12 = []
    map13 = []
    map14 = []
    map15 = []
    map16 = []
    map17 = []
    map18 = []
    map19 = []
    map20 = []
    map21 = []
    map22 = []
    map23 = []
    map24 = []
    map25 = []
    map26 = []
    map27 = []
    map28 = []
    map29 = []
    map30 = []
    
    
    #lol
    
    map12  = []
    map22  = []
    map32  = []
    map42  = []
    map52  = []
    map62  = []
    map72  = []
    map82  = []
    map92  = []
    map102 = []
    map112 = []
    map122 = []
    map132 = []
    map142 = []
    map152 = []
    map162 = []
    map172 = []
    map182 = []
    map192 = []
    map202 = []
    map212 = []
    map222 = []
    map232 = []
    map242 = []
    map252 = []
    map262 = []
    map272 = []
    map282 = []
    map292 = []
    map302 = []






    
    #decompiliation
    if map.startswith("S"):
        temp =map.split(",")
        map_loading = locations_submaps[int(temp[1])]
    else:
        map_loading = map_saves[map_saves_location.index(map)]
    

    
    temp = map_loading.split("/")
    maps = [map1,map2,map3,map4,map5,map6,map7,map8,map9,map10,map11,map12,map13,map14,map15,map16,map17,map18,map19,map20,map21,map22,map23,map24,map25,map26,map27,map28,map29,map30]
    maps2 = [map12,map22,map32,map42,map52,map62,map72,map82,map92,map102,map112,map122,map132,map142,map152,map162,map172,map182,map192,map202,map212,map222,map232,map242,map252,map262,map272,map282,map292,map302]

    # number - icon
    '''
    0 - water
    1 - Trees
    2 - Plains
    3 - Mountans
    4 - Wall
    5 - Interaction Point
    '''




    for x in range(30):
        temp2 = temp[x]
        temp3 = temp2.split("_")
        for i in range(30):
            #translates string into the accual desplay
            temp4 = biome_desplay[int(temp3[i])]
            #adds it to the map desplay
            maps[x].append(temp4)
            maps[x].append(" ")
            
    #I did not in fact need to enumerate, I just needed for line 384 to refrance x instead of i, and same for line 369, I think the intire problem stemed from me hurriedly finishing this up and not dubble checking it before I had to go    

    #other stuff like towns and caves
    this_location_elements = locations_location.copy()
    this_location_locations = locations.copy()
    this_location_map_locations = locations_map_location.copy()
    if len(this_location_locations) > 0:
        temp99999 = 0
        for i in range(len(this_location_elements)):
            if this_location_elements[i-temp99999] == map:
                pass
            else:
                this_location_elements.pop(i-temp99999)
                this_location_locations.pop(i-temp99999)
                this_location_map_locations.pop(i-temp99999)
                temp99999 +=1
        for i in range(len(this_location_elements)):
            map_location_split = this_location_map_locations[i].split(",")
        
            if this_location_locations[i] == "Player":
                desplay_element = "\u265F"
                player_zone = maps[int(map_location_split[1])][int(map_location_split[0])*2]
            elif this_location_locations[i] == "Town":
                desplay_element = "\u26EA"
            elif this_location_locations[i] == "Cave":
                desplay_element = "\u26EB"
            elif this_location_locations[i] == "Exit":
                desplay_element = "\u26CB"
            elif this_location_locations[i] == "Shop":
                desplay_element = "\u26C0"
            elif this_location_locations[i] == "Church":
                desplay_element = "\u26CB"
            else:
                desplay_element = "ERROR"
            templist = ("Town","Cave")
            if maps[int(map_location_split[1])][int(map_location_split[0])*2] != "\u265F":
                maps[int(map_location_split[1])].pop(int(map_location_split[0])*2) 
                maps[int(map_location_split[1])].insert(int(map_location_split[0])*2,desplay_element)







    #printing the map
    print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
    for x in range(30):
        for i in maps[x]:
            print(i,end="")
        print()
    print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
    valid_awnsers = ["W","A","S","D","w","a","s","d"]
    idiotloop = 0
    print(colors[2]+"Enter WASD to move"+colors[9])
    while idiotloop == 0:
        try:
            examine = input()
            if examine in valid_awnsers:
                pass
            else:
                raise
        except:
            print(colors[1]+"Invalid input, valid inputs include",str(valid_awnsers)+colors[9])
        else:
            idiotloop = 1
    
    
    
    
    #actions
    walls = [4]
    if examine == "W" or examine =="w":

        listlocation = locations.index("Player")
        player_location = locations_map_location[listlocation].split(",")
        player_locationx = int(player_location[0])
        player_locationy = int(player_location[1])
        if player_locationy == 0:
            temp999 = locations_location[locations.index("Player")].split(",")
            temp999[0] = int(temp999[0])
            temp999[1] = int (temp999[1])
            temp999[1] -= 1
            if map_saves_location.count(str(temp999[0])+","+str(temp999[1])) == 0:
                Generate_Map(str(temp999[0])+","+str(temp999[1]))
            temp = map_saves[map_saves_location.index(str(temp999[0])+","+str(temp999[1]))].split("/")
            for x in range(30):
                    temp2 = temp[x]
                    temp3 = temp2.split("_")
                    for i in range(30):
                        #translates string into the accual desplay
                        temp4 = biome_desplay[int(temp3[i])]
                        #adds it to the map desplay
                        maps2[x].append(temp4)
                        maps2[x].append(" ")
            if walls.count(maps2[29][player_locationx]) > 0:
                print("thats a wall dummy")
            else:
                if player_locationy != 0:
                    player_locationy -= 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[1] -= 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(temp8[0]+","+str(29))
                    locations_map_location.insert(listlocation,temp9)
        else:
            if walls.count(biome_desplay.index(maps[int(player_location[1])-1][int(player_location[0])*2])) > 0:
                print("thats a wall dummy")
            else:
                if player_locationy != 0:
                    player_locationy -= 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[1] -= 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(temp8[0]+","+str(29))
                    locations_map_location.insert(listlocation,temp9)
    if examine == "S" or examine =="s":

        listlocation = locations.index("Player")
        player_location = locations_map_location[listlocation].split(",")
        player_locationx = int(player_location[0])
        player_locationy = int(player_location[1])
        if player_locationy == 29:
            temp999 = locations_location[locations.index("Player")].split(",")
            temp999[0] = int(temp999[0])
            temp999[1] = int (temp999[1])
            temp999[1] += 1
            if map_saves_location.count(str(temp999[0])+","+str(temp999[1])) == 0:
                Generate_Map(str(temp999[0])+","+str(temp999[1]))
            temp = map_saves[map_saves_location.index(str(temp999[0])+","+str(temp999[1]))].split("/")
            for x in range(30):
                    temp2 = temp[x]
                    temp3 = temp2.split("_")
                    for i in range(30):
                        #translates string into the accual desplay
                        temp4 = biome_desplay[int(temp3[i])]
                        #adds it to the map desplay
                        maps2[x].append(temp4)
                        maps2[x].append(" ")
            if walls.count(maps2[0][player_locationx]) > 0:
                print("thats a wall dummy")
            else:
                if player_locationy != 29:
                    player_locationy += 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[1] += 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(temp8[0]+","+str(0))
                    locations_map_location.insert(listlocation,temp9)
        else:
            if walls.count(biome_desplay.index(maps[int(player_location[1])+1][int(player_location[0])*2])) > 0:
                print("thats a wall dummy")
            else:
                if player_locationy != 29:
                    player_locationy += 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[1] += 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(temp8[0]+","+str(0))
                    locations_map_location.insert(listlocation,temp9)
    if examine == "A" or examine == "a":

        listlocation = locations.index("Player")
        player_location = locations_map_location[listlocation].split(",")
        player_locationx = int(player_location[0])
        player_locationy = int(player_location[1])
        if player_locationx == 0:
            temp999 = locations_location[locations.index("Player")].split(",")
            temp999[0] = int(temp999[0])
            temp999[1] = int (temp999[1])
            temp999[0] -= 1
            if map_saves_location.count(str(temp999[0])+","+str(temp999[1])) == 0:
                Generate_Map(str(temp999[0])+","+str(temp999[1]))
            temp = map_saves[map_saves_location.index(str(temp999[0])+","+str(temp999[1]))].split("/")
            for x in range(30):
                    temp2 = temp[x]
                    temp3 = temp2.split("_")
                    for i in range(30):
                        #translates string into the accual desplay
                        temp4 = biome_desplay[int(temp3[i])]
                        #adds it to the map desplay
                        maps2[x].append(temp4)
                        maps2[x].append(" ")
            if walls.count(maps2[player_locationx][29]) > 0:
                print("thats a wall dummy")
            else:
                if player_locationx != 0:
                    player_locationx -= 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[0] -= 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(str(29)+","+temp8[1])
                    locations_map_location.insert(listlocation,temp9)
        else:
            if walls.count(biome_desplay.index(maps[int(player_location[1])][int(player_location[0])*2-2])) > 0:
                print("thats a wall dummy")
            else:
                if player_locationx != 0:
                    player_locationx -= 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[0] -= 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(str(29)+","+temp8[1])
                    locations_map_location.insert(listlocation,temp9)
    if examine == "D" or examine == "d":

        listlocation = locations.index("Player")
        player_location = locations_map_location[listlocation].split(",")
        player_locationx = int(player_location[0])
        player_locationy = int(player_location[1])
        if player_locationx == 29:
            temp999 = locations_location[locations.index("Player")].split(",")
            temp999[0] = int(temp999[0])
            temp999[1] = int (temp999[1])
            temp999[0] += 1
            if map_saves_location.count(str(temp999[0])+","+str(temp999[1])) == 0:
                Generate_Map(str(temp999[0])+","+str(temp999[1]))
            temp = map_saves[map_saves_location.index(str(temp999[0])+","+str(temp999[1]))].split("/")
            for x in range(30):
                    temp2 = temp[x]
                    temp3 = temp2.split("_")
                    for i in range(30):
                        #translates string into the accual desplay
                        temp4 = biome_desplay[int(temp3[i])]
                        #adds it to the map desplay
                        maps2[x].append(temp4)
                        maps2[x].append(" ")
            if walls.count(maps2[player_locationx][0]) > 0:
                print("thats a wall dummy")
            else:
                if player_locationx != 29:
                    player_locationx += 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[0] += 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(str(0)+","+temp8[1])
                    locations_map_location.insert(listlocation,temp9)
        else:
            if walls.count(biome_desplay.index(maps[int(player_location[1])][int(player_location[0])*2+2])) > 0:
                print("thats a wall dummy")
            else:
                if player_locationx != 29:
                    player_locationx += 1
                    locations_map_location.pop(listlocation)
                    locations_map_location.insert(listlocation,(str(player_locationx)+","+str(player_locationy)))
                else:
                    temp5 = locations_location[listlocation].split(",")
                    temp5[0] = int(temp5[0])
                    temp5[1] = int(temp5[1])
                    temp5[0] += 1
                    temp6 = str(temp5[0])+","+str(temp5[1])
                    temp8 = locations_map_location[listlocation].split(",")
                    try:
                        temp99 = map_saves_location.index(temp6)
                    except:
                        Generate_Map(temp6)
                        temp99 = map_saves_location.index(temp6)
                    locations_location.pop(listlocation)
                    locations_location.insert(listlocation,temp6)
                    locations_map_location.pop(listlocation)
                    temp9 = str(str(0)+","+temp8[1])
                    locations_map_location.insert(listlocation,temp9)
    if examine == "W" or examine =="w" or examine == "S" or examine =="s" or examine == "A" or examine == "a" or examine == "D" or examine == "d":
    #mob encounters
        if random.randint(1,biome_mob_chance[biome_desplay.index(player_zone)]) == 1:
            if random.randint(1,10) == 10:
                ts = 2
            else:
                ts = 1
            for i in range(0,2):
                if biome_mobs[biome_desplay.index(player_zone)] != '':
                    mobs = biome_mobs[biome_desplay.index(player_zone)].split(",")
                    temp = random.randint(0,len(mobs)-1)
                    enemy.append(int(mobs[int(temp)]))
                    gamestate = 1
def Generate_Map(map_location):
    global map_saves
    global map_saves_location
    global submap_saves
    global submap_saves_location
    global biome_list
    global valid_stuff
    global locations_submaps

    map1  = []
    map2  = []
    map3  = []
    map4  = []
    map5  = []
    map6  = []
    map7  = []
    map8  = []
    map9  = []
    map10 = []
    map11 = []
    map12 = []
    map13 = []
    map14 = []
    map15 = []
    map16 = []
    map17 = []
    map18 = []
    map19 = []
    map20 = []
    map21 = []
    map22 = []
    map23 = []
    map24 = []
    map25 = []
    map26 = []
    map27 = []
    map28 = []
    map29 = []
    map30 = []
    maps_list = [map1,map2,map3,map4,map5,map6,map7,map8,map9,map10,map11,map12,map13,map14,map15,map16,map17,map18,map19,map20,map21,map22,map23,map24,map25,map26,map27,map28,map29,map30]

    if map_location.startswith("S_") == False:
        
        
        
        
        #detects if there are maps around it
        temp1 = map_location.split(",")
        tempx = int(temp1[0])
        tempy = int(temp1[1])
        tempxtest = tempx + 1
        temptest = str(tempxtest)+","+str(tempy)
        try:
            map_r = map_saves_location.index(temptest)
        except:
            map_r = "N/A"
        tempxtest = tempx - 1
        temptest = str(tempxtest)+","+str(tempy)
        try:
            map_l = map_saves_location.index(temptest)
        except:
            map_l = "N/A"
        tempytest = tempy + 1
        temptest = str(tempx)+","+str(tempytest)
        try:
            map_u = map_saves_location(temptest)
        except:
            map_u = "N/A"
        tempytest = tempy - 1
        temptest = str(tempx)+","+str(tempytest)
        try:
            map_d = map_saves_location(temptest)
        except:
            map_d = "N/A"
        
        
        #decompiles maps edges around it

        if map_l == "N/A":
            pass
        else:
            temp1 = map_saves[map_l].split("/")
            map_l = []
            for x in range(30):
                temp2 = temp1[x].split("_")
                map_l.append(temp2[29])
        if map_r == "N/A":
            pass
        else:
            temp1 = map_saves[map_r].split("/")
            map_r = []
            for x in range(30):
                temp2 = temp1[x].split("_")
                map_r.append(temp2[29])
        if map_u == "N/A":
            pass
        else:
            temp1 = map_saves[map_u].split("/")
            map_u = []
            for x in range(30):
                temp2 = temp1[x].split("_")
                map_u.append(temp2[29])
        if map_d == "N/A":
            pass
        else:
            temp1 = map_saves[map_d].split("/")
            map_d = []
            for x in range(30):
                temp2 = temp1[x].split("_")
                map_d.append(temp2[29])

        Generated_map = []
        
        map_assemble = ""
        for x in range(30):
            for i in range(30):

                
                #detects sourounding areas
                biome_chances = []
                if x == 0:
                    if map_u == "N/A" or len(map_u) < i+1:
                        pass
                    else:
                        biome_chances.append(map_u[i])
                elif map_u == "N/A" or len(map_u) < i+1:
                    pass
                else:
                    biome_chances.append(map_u[i])
                if x == 29:
                    if map_d == "N/A" or len(map_d) < i+1:
                        pass
                    else:
                        biome_chances.append(map_d[i])
                elif map_d == "N/A" or len(map_d) < i+1:
                    pass
                else:
                    biome_chances.append(map_d[i])
                if i == 0:
                    if map_l == "N/A" or len(map_l) < i+1:
                        pass
                    else:
                        biome_chances.append(map_l[i])
                elif map_l == "N/A" or len(map_l) < i+1:
                    pass
                else:
                    biome_chances.append(map_l[i-1])
                if i == 29:
                    if map_r == "N/A" or len(map_r) < i+1:
                        pass
                    else:
                        biome_chances.append(map_r[i])
                elif map_r == "N/A" or len(map_r) < i+1:
                    pass
                else:
                    biome_chances.append(map_r[i+1])

                #calculates chances for each biome depending on sourounding area
                #95% chance to be one of the biomes around it
                #5% chance to be a new biome
                if len(biome_chances) == 0:
                    biome = random.randint(0,len(biome_list)-1)

                if len(biome_chances) >= 1:
                    randombiome = random.randint(0,100)
                    if randombiome <= 95:
                        biome = biome_chances[random.randint(0,len(biome_chances)-1)]

                    else:
                        biome = random.randint(0,len(biome_list)-1)



                #saves data in a list
                if map_u == "N/A":
                    map_u = []
                if map_l == "N/A":
                    map_l = []
                maps_list[x].append(str(biome))
                map_l.insert(i,str(biome))
                try:
                    map_l.pop(i+1)
                except:
                    pass
                map_u.insert(i,str(biome))
                try:
                    map_u.pop(i+1)
                except:
                    pass
                map_assemble += str(biome)+"_"
            map_assemble += "/"
        map_saves.append(map_assemble)
        map_saves_location.append(map_location)


        #locations = ["Player"]
        #locations_location = ["0,0"]
        #locations_map_location = ["14,14"]


        #locations
        #finds biome
        if name == "\x1b[34mbug\x1b[39m":
            x = 13
            y = 13
        else:
            x = random.randint(0,29)
            y = random.randint(0,29)
        spot = maps_list[x][y]
        #checks for valid stuff to put there
        temp = valid_stuff[int(spot)].split(",")
        #rolls for what it will be
        if temp[0] != '':
            temp2 = random.randint(0,len(temp)-1)
            structure = int(temp[temp2])   
            if structure == 0:
                structure = "Town"
                Generate_Map("S_T")
            elif structure == 1:
                structure = "Cave"
                Generate_Map("S_C")
            locations.append(structure)
            locations_location.append(map_location)
            locations_map_location.append(str(x)+","+str(y))
            locations_submaps_spawn.append("15,27")
            
            
            locations.append("Exit")
            locations_location.append("S,"+str(len(locations)-2))
            locations_map_location.append("16,28")
            locations_submaps_spawn.append("N/A")
            locations_submaps.append("F_0_0")
            
            
            locations.append("Exit")
            locations_location.append("S,"+str(len(locations)-3))
            locations_map_location.append("15,28")
            locations_submaps_spawn.append("N/A")
            locations_submaps.append("F_0_0")
            
            
            common_cards = [4,5,7,8,9,12]
            uncommon_cards = [6,10,11]
            rare_cards = [0]
            epic_cards = [0]
            legendary_cards = [0]

            locations.append("Shop")
            locations_location.append("S,"+str(len(locations)-4))
            locations_map_location.append("5,18")
            temp2 = ""
            atemp = random.randint(2,5)
            for i in range(0,atemp):
                if random.randint(1,100) == 100:
                    temp = legendary_cards[random.randint(0,len(legendary_cards)-1)]
                elif random.randint(1,50) == 80:
                    temp = epic_cards[random.randint(0,len(epic_cards)-1)]
                elif random.randint(1,25) == 25:
                    temp = rare_cards[random.randint(0,len(rare_cards)-1)]
                elif random.randint(1,10) == 10:
                    temp = uncommon_cards[random.randint(0,len(uncommon_cards)-1)]
                else:
                    temp = common_cards[random.randint(0,len(common_cards)-1)]
                tempp = random.randint(0,40)
                if tempp <20:
                    tempp = 1-(tempp/100)
                elif tempp >20:
                    tempp = 1+(tempp/100)
                else:
                    tempp = 1
                if i == 0:
                    temp2 = str(temp)+"_"+str(round(cards_def_price[temp]*tempp))+"_"+"0"
                else:
                    temp2 = str(temp2)+"_" + str(temp)+"_"+str(round(cards_def_price[temp]*tempp))+"_"+"0"
            
            locations_submaps_spawn.append(temp2)
            locations_submaps.append("F_1_"+str(len(locations)-1))

            locations.append("Church")
            locations_location.append("S,"+str(len(locations)-5))
            locations_map_location.append("23,24")
            locations_submaps_spawn.append("N/A")
            locations_submaps.append("F_2_0")

    else:

        
        
        locations_submaps.append("4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_/4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_4_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_4_4_8_8_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_4_4_9_4_/4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_8_8_8_8_8_8_8_8_4_9_4_/4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_8_8_8_8_8_8_8_4_9_4_/4_9_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/4_9_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_8_4_4_9_4_/4_9_4_8_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/4_9_4_8_4_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/4_9_4_8_4_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_4_4_9_4_/4_9_4_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/4_9_4_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_8_8_8_8_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/4_9_4_8_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_4_4_4_8_8_8_8_8_4_9_4_/4_9_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_9_4_/4_9_9_9_9_9_9_9_9_9_9_9_4_4_4_9_9_4_4_4_9_9_9_9_9_9_9_9_9_4_/4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_/")
def Manual_map_editor():
    OSError.exit()
    # 4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_/
    # 4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_4_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_8_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_4_4_8_8_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_4_4_9_4_/
    # 4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_8_4_4_9_4_/
    # 4_9_4_8_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/
    # 4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/
    # 4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/
    # 4_9_4_8_4_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/
    # 4_9_4_8_4_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_9_9_9_9_9_9_9_4_9_4_/
    # 4_9_4_8_4_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_4_4_9_4_/
    # 4_9_4_8_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_9_4_/
    # 4_9_4_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_4_4_4_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_8_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_4_9_9_9_9_9_9_9_9_9_9_4_8_8_8_8_8_8_8_8_4_9_4_/
    # 4_9_4_8_8_8_8_8_9_9_9_9_9_9_9_9_9_9_4_4_4_4_8_8_8_8_8_4_9_4_/
    # 4_9_4_4_4_4_4_4_9_9_9_9_9_9_9_9_9_9_9_9_9_4_4_4_4_4_4_4_9_4_/
    # 4_9_9_9_9_9_9_9_9_9_9_9_4_4_4_9_9_4_4_4_9_9_9_9_9_9_9_9_9_4_/
    # 4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_4_/      
def Exit(nope):
    global locations, locations_location, locations_map_location, out
    player_location = locations.index("Player")
    temp = str(locations_map_location[int(locations_location[player_location].split(",")[1])])
    temp2 = str(locations_location[int(locations_location[player_location].split(",")[1])])    
    locations_location[player_location] = temp2
    locations_map_location[player_location] = temp
    out = True
def Dialouge(person):
    global out, HP, MaxHP
    person = int(person)
    npc = 0
    if person == 0:
        desplay = ["Welcome to the church of the bool, how can i help you?","Not yet avalable","May the bool judge you true."]
        actions = ["Save (N/A)_Heal","Exit","Exit"]
        link = ["1_2","F,0","F,1"]
    else:
        desplay = ["There has been a error in the dialouge code"]
        actions = ["exit"]
        link = ["F,0"]





    con = True
    while con == True:
        print(colors[3]+desplay[npc]+colors[9])
        print(colors[2],actions[npc].split("_"),"{ Enter number }"+colors[9])
        valid = []
        for i in range(0,len(actions[npc].split("_"))):
            valid.append(i+1)

        idl = True
        while idl == True:
            try:
                a = int(input())
                if a in valid:
                    idl = False
                else:
                    print(colors[2],actions[npc].split("_"),"{ Enter number }"+colors[9])
            except:
                print(colors[2],actions[npc].split("_"),"{ Enter number }"+colors[9])
        
        
        temp = link[npc].split("_")
        if temp[a-1].startswith("F"):
            temp3 = temp[a-1].split(",")
            temp2 = int(temp3[1])
            if temp2 == 0:
                con = False
                out = True
            elif temp2 == 1:
                HP = MaxHP
                con = False
                out = True
            else:
                print("Function not created")
                OSError.exit()
        else:
            npc = int(temp[a-1])
def Shop(shop_stuff):
    global cards_descrition, cards_names, currency, Deck, out

    shop_items = []
    shop_prices = []
    shop_items_type = []
    temp = locations_submaps_spawn[int(shop_stuff)].split("_")
    for i in range(0,int(len(temp)/3)):
        shop_items.append(int(temp[i*3-3]))
        shop_prices.append(int(temp[i*3-2]))
        if int(temp[i*3-1]) == 0:
            shop_items_type.append("card")

    debug(shop_items)
    debug(shop_prices)
    debug(shop_items_type)

    hover = 0
    shop_items.append("exit")
    shop_prices.append("exit")
    shop_items_type.append("exit")
    
    #asci art
    door = ("   _________    ","   |       |    ","   |     O |    ","   |     ' |    ") 
    pysical_card = (colors[1]+"   ________     "+colors[9],colors[1]+"   \   _I_ \    "+colors[9],colors[1]+"    \  | |  \   "+colors[9],colors[1]+"     \__v____\  "+colors[9])
    magic_card = (colors[5]+"   ________     "+colors[9],colors[5]+"   \    ^  \    "+colors[9],colors[5]+"    \  {*}  \   "+colors[9],colors[5]+"     \__v____\  "+colors[9])
    mystery_card = ("   ________     ","   \       \    ","    \   ?   \   ","     \_______\  ")

    
    asci_items = (door,pysical_card,magic_card,mystery_card)




    #shopkeep
    normal_face = ("      _      ","    / ..\    ","  __\ - /__  "," /         \ ")
    unhappy_face = ("      _      ","    / ..\    ","  __\ ^ /__  "," /         \ ")
    happy_face = ("      _      ","    / ..\    ","  __\ v /__  "," /         \ ")
    faces = (normal_face,unhappy_face,happy_face)



    face = 0
    asci_item = 0
    pruchased = False
    exit = False
    #desplay
    while exit == False:
        for i in range(0,20):
            print()
        if pruchased == True:
            face = 2
        else:
            if (hover + 1) == len(shop_items) and pruchased == False:
                face = 1
            else:
                face = 0
        if (hover + 1) == len(shop_items):
            asci_item = 0
        else:
            if shop_items_type[hover] == "card":
                
                if type(cards_type[shop_items[hover]]) == str:
                    temp = cards_type[shop_items[hover]].split("_")
                    for i in range(0,len(temp)):
                        temp[i] = int(temp[i])
                    if 0 in temp:
                        asci_item = 1
                    elif 1 in temp:
                        asci_item = 2
                    else:
                        asci_item = 3
                else:
                    temp = cards_type[shop_items[hover]]
                    if 0 == temp:
                        asci_item = 1
                    elif 1 == temp:
                        asci_item = 2
                    else:
                        asci_item = 3

        print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        print("|"+faces[face][0]+"|"+asci_items[asci_item][0]+"|")
        print("|"+faces[face][1]+"|"+asci_items[asci_item][1]+"|")
        print("|"+faces[face][2]+"|"+asci_items[asci_item][2]+"|")
        print("|"+faces[face][3]+"|"+asci_items[asci_item][3]+"|")
        print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        if (hover + 1) != len(shop_items):
            print(cards_description[shop_items[hover]])
        else:
            if pruchased == True: 
                print("Come again!")
            else:
                print(":(")
        print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        for i in range(0,len(shop_items)):
            if hover == i:
                print("\u265F ",end="")
            else:
                print("\u26C0 ",end="")
            if (i+1) != len(shop_items): 
                print(cards_names[shop_items[i]],"("+str(shop_prices[i])+")")
            else:
                print("Leave")
        print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
        print(colors[2]+"Press enter to buy, or enter w or s to reselect"+colors[9])
        a = 0
        while a != "W" and a != "w" and a != "S" and a != "s" and a != "":
            a = input()
            if a != "W" and a != "w" and a != "S" and a != "s" and a != "":
                print(colors[2]+"Press enter to buy, or enter w or s to reselect"+colors[9])
        if a == "W" or a == "w":
            if hover == 0:
                hover = (len(shop_items) - 1)
            else:
                hover -= 1
        if a == "S" or a == "s":
            if (hover + 1) == len(shop_items):
                hover = 0
            else:
                hover += 1
        if a == "":
            if (hover + 1) == len(shop_items):
                exit = True
                out = True
            else:
                if currency >= shop_prices[hover]:
                    currency -= shop_prices[hover]
                    
                    
                    if shop_items_type[hover] == "card":
                        Deck.append(shop_items[hover])
                    
                    shop_items.pop(hover)
                    shop_items_type.pop(hover)
                    shop_prices.pop(hover)
                    pruchased = True

                else:
                    print(colors[1]+"Not enough currency"+colors[9])
                    input(colors[2]+"Press enter to continue"+colors[9])

                

                

    



func_list = [Exit,Shop,Dialouge]




Generate_Map("0,0")
out = False




while gamestate != -1:
    while gamestate == 0:
        #dubug
        if name == "\x1b[34mbug\x1b[39m":
            print(locations)
            print(locations_location)
            print(locations_map_location)
            print(locations_submaps_spawn)
            print(gamestate)
            print(locations_submaps)
        
        
        player_index = locations.index("Player")
        player_map_location = locations_map_location[player_index]
        
        
        this_location_locations = locations_location.copy()
        this_location_map_locations = locations_map_location.copy()
        temp_remove = []
        cordination = []
        for i in range(0, len(this_location_locations)):
            cordination.append(i)
        for i in range(0,len(this_location_locations)):

            if this_location_locations[i] == locations_location[player_index]:
                pass
            else:
                temp_remove.append(i)
        temp_remove.reverse()
        for i in range(0,len(temp_remove)):
            this_location_map_locations.pop(temp_remove[i])
            cordination.pop(temp_remove[i])
        debug(player_map_location)
        debug(this_location_map_locations)


        try:
            location_standing_on = cordination[this_location_map_locations.index(player_map_location,1)]
            debug(locations_submaps[location_standing_on])

        except:
            location_standing_on = "N/A"
        
        
        
        temp_bool = False
        try:
            if locations_submaps[location_standing_on].startswith("F"):
                temp_bool = True
        except:
            pass
        

        #FOR DEBUG TESTING
        #location_standing_on is the index of whatever location the player is standing on
        #cordination is used so that the index of location_standing_on is the global index and not the local
        
        
        if temp_bool and out == False:
            func_list[int(locations_submaps[location_standing_on].split("_")[1])](locations_submaps[location_standing_on].split("_")[2])
        elif out == True or location_standing_on == "N/A":
            Refresh_Map(locations_location[player_index])
            out = False
        else:
            locations_location[player_index] = "S,"+str(location_standing_on)
            locations_map_location[player_index] = locations_submaps_spawn[location_standing_on]
            Refresh_Map("S,"+str(location_standing_on))



    if gamestate == 1:
        Encoutner_setup()
    while gamestate == 1:
        Refresh_hud()
        if HP <= 0:
            print("Game Over")
            gamestate = -1
        if len(enemy) == 0:
            print("Enemy Defeated!")
            gamestate = 0